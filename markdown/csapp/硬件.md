
## 零碎的硬件知识

- ### 主存

主存是一个临时的存储结构, 用来存放程序和程序的数据的. 
**由一组动态随机储存器芯片组成**
主存可以看成是一个很大的数组, 里面存放的数据都可以通过地址索引的方式找到. 并且每个数据都对应了唯一的地址号.
**组成程序的每一条指令都由不同数量的字节组成**

> 存储器和时钟
> **时钟存储器 : 存储单个位或字. 等待时钟信号到来在执行加载输入/输出( 时钟上升沿->执行读写操作 下降沿保持不变 )**
> **随机存储器 : 随机访问内存中的单元.**


- ### 处理器

**用来处理存放在主存中数据指令的处理引擎**
**在任何时候 PC 都指向下一条指令****的地址单元**

> 处理器架构
> 1. 指令集架构 : 一个处理器支持的指令和指令级编码.(一个指令被编码成一个或多个字节组成的二进制格式)**最重要的就是, 一个指令只能有唯一的解释**
> 就像键盘的扫描码, 每个一按键都对应唯一的编码, A 按下的扫描码就是1E, 松开就是9E.
> 2. 微体系结构 : 处理器用来执行底层系统设计.

- ### 高速缓存

将近期处理过的数据或指令存放在缓存中, 以便不久的将来的可能会用到, 就可以直接调用缓存中存放的数据, 而不用去查找内存甚至是磁盘. 因为查找内存和磁盘的开销可能是引用缓存的几百倍甚至上千倍.
L1, L2静态高速缓存(SRAM)以及动态高速缓存(DRAM).

**高速缓存具有局部性**
> 局部性
> 1. 空间局部性 : 调用的数据项的周围数据项可能不久也会被引用, 所以也存储缓存中.
> 2. 时间局部性 : 调用的数据项可能不久也会重复的被调用, 同样存放在缓存中.

- ### 操作系统

所有对硬件的操作都会经过操作系统.
> 功能
> 1. 防止硬件被应用程序滥用
> 2. 向应用程序提供一种简单的机制来控制对硬件的操作.

- ### 进程

**进程是操作系统对一个正在执行的程序的一种抽象.**
每个进程看起来都是独立占有系统资源和硬件的.
> 1. *并发*
> **并发运行 : 进程指令和另一进程的指令是交错执行的**
> 一个CPU看起来就像是同时处理多个进程, **实则是CPU在很短的时间内来回在多个进程之间进行切换, 处理不同进程的不同指令**, 所以说**宏观看起来的并发执行程序, 微观其实是并行执行每个程序的**.
> 2. *上下文切换*
> 当从一个进程切换到另一个进程时, 系统会保留现在进程的数据, 通过**内核调度**换到另一个进程. 
> **内核为每个进程维持一个上下文**

### **上下文切换的实质**

**内核会调用PCB(进程管理控制块), 将程序, 数据保留下来, 在切换到新的进程**

**PCB 是进程存在的唯一标志** (其实最开始我也不明为什么, 因为进程的标志的不是进程ID吗?)

PCB是存在**task_struct结构体**中. 而**task_struct 存放在内核栈中(约8kb, 占1kb左右),系统通过PID调用哈希表直接快速的找到所指向的task_struct指针** 
```c
struct task_struct
{
    ...
    unsigned short uid;             // 保存用户的ID
    int pid;                        // 进程ID
    int processor;                  // 标识用户正在使用的CPU,以支持对称多处理机方式
    ...
    volatile long status;           // 进程存在的6种状态, 运行, 中断, 不可中断, 僵尸, 暂停, 交换态
    long prority;                   // 进程优先级
    unsighed long rt_prority;
    long counter;                   // 优先级计数, 用于轮转调度算法
    unsigned long flags;
    unsigned long policy;           // 调度策略 
    ...
    struct task_struct *next_task, *prev_task;                      // 双链表指向上下结构
    struct task_struct *next_run,*prev_run;                         // 双链表指向运行进程的上下文
    struct task_struct *p_opptr,*p_pptr,*p_cptr,*pysptr,*p_ptr;     // 指向子进程, 父进程等
    ...
};
```

- **调度进程 : 在linux是init0的进程进行的, init0是系统进程也被称为交换进程, 它是属于内核的一部分, 不执行磁盘上的任何程序**

详细的解析可以看这个博客, 很详细 : https://blog.csdn.net/Scenlyf/article/details/51644307

状态图:
```mermaid
graph TD

```

- - -

- ### 虚拟内存

程序将内存视为一个很大的数组. 每个内存空间都有唯一的数字表示, 称为虚拟地址空间. 而这样集合的组成就是虚拟地址空间.

**程序可以视为一个字节块(包含一个小的地址空间), 而程序本身就是一个字节序列**

而**一个字长度也就是一个虚拟地址的长度. 字长也就决定了虚拟地址空间的最大长度**. 一个4子的长度, 那么虚拟地址长度就是(2的4次方 - 1), 虚拟地址空间长度就是, 2的4次方.

- ### 栈

函数调用会使用栈, 当程序调用函数的时候,会引用call, 下一条指令的地址也就函数的地址会存放在pc中, 而将函数之后的地址压入栈, 以便函数调用完恢复到当前的位置. 将传人的变量用寄存器存放起来. 但是超过6个变量的话, 其他的变量就将压入栈来达到变量的传递. 当变量改变当作返回时, 也将其压入栈中, 在函数返回到之前调用位置时, 将压入的变量进行出栈操作, 这就达到了返回值的功能.
**不过, 在通过栈传递时, 所有的数据的字节都是当成是8的倍数, 不管是char, short类型, 都是传递的8的倍数个字节**
局部变量的创建也是在栈开辟空间, 直接使用寻址方式调用局部变量的, 每次的局部变量都会调用栈的寻址操作. 当局部变量的生命周期结束时, 就会在出栈, 释放掉占用的空间.

但是对于栈的安全性, 避免栈被破坏, 栈溢出(比如使用gets, scanf没有限制字符长度的保护), 避免其他的数据被覆盖掉, 也避免被其他人攻破, 所以**栈采用, 随机化, 在每个电脑的空间不尽相同**. **同时为了避免数据被输入溢出所覆盖, 在栈帧中任何局部缓冲都加有一个金丝雀(栈保护者, 哨兵值), 这个区域的数据每次都是随机化的, 但是程序每次返回时会检查哨兵值是否改变(采用简单的'xor'判断哨兵值的改变), 如果发生了改变程不序就会抛出错误**

- - -

## 指令处理的阶段

1. **取指 : 获取当前PC所指的地址指令. 用临时变量保存(PC + 1)的值, 并且取出要操作的变量.**
2. **译码 : 从寄存器文件最多取出两个操作数.**
3. **执行 : 在ALU执行基本操作.**
4. **访存 : 将数据写回内存, 或者从内存写回到寄存器.**
5. **写回 : 将结果写到寄存器.**
6. **更新PC : 将临时变量写到PC中.**

- - -

### 流水线

**流水线寄存器**

将一个处理分成多个操作, 进而缩短每个操作所用的平均时间.
流水线会提高吞吐量, 但是不会缩短每条指令执行的时间.

只要执行的运算是连续的, 逻辑上是独立的, 就可以使用流水线处理.


- **流水线冒险**
阻止下一条指令周期开始执行.


## 分支预测

PC始终指向下一条指令的地址, 所以, 当遇到分支的时候, 就会不知所措. 所以希望在遇到分支的时候, 系统能自动的预测程序的走向, 系统会通过概率计算出哪一条分支的可能性要大, 然后PC就指向那一条指令.
并且程序也会事先就会执行指令的操作, 当预测正确的时候, 程序会直接进行刚预测的操作; 相反, 当预测错误的时候系统会丢弃刚执行的操作,并且立马执行另一个操作.
但是重要的就是, **判断错误的代价会是很大的, 不仅丢弃之前的所有预测操作, 还要重新快速执行当前指令, 所以错误的预测处罚很大**




















