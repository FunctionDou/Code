## 链接

将各个代码和数据片段收集起来并组合合成一个单一的文件的过程. 这个文件可被加载(复制)到内存中执行.

- - -

- ### 编译器

在编译阶段编译器会将代码中所定义的函数声明, 定义分配一个符号定义, 不同函数有不同的定义. 当遇到相同名字的函数的时候, 编译器不明确与哪一个函数链接起来, 这时编译器就会报错.

```shell
# 编译阶段, 生成 .s 文件
gcc -S t.cpp
```

1. **强符号 : 对于每个全局变量, 静态变量并且初始化过的都分配一个.data的链接器表条目.**
2. **弱符号 : 当遇到没有初始化的全局变量, 编译器会将其分配一个.bss文件条目, 这样没有初始化的变量编译器并<font color=#b20>不为其分配一个地址, 而只是有一个占位符, 不占用磁盘空间</font>. 同样, 如果遇到多个相同的变量名但是没有初始化, 编译器都不会报错, 而都只是分配一个占位符而已.**
3. **当出现了extren的外部变量, 编译器只会为变量分配一个编译器符号条目表, 剩下的数据链接, 资源链接都教给链接器来完成.** 

> - <font color=#b20>私有变量 : 遇到函数中定义static 的变量, 链接器会将其分配是这个函数私有的变量, 与其他的函数声明定义的static 相同的变量不会发生冲突.
</font>
> - 公有变量 : 定义的全局变量就是公有的变量, 函数都可以访问.

- - -

- ### 链接器(ld)

**编译阶段分配的extren的编译器符号表条目在链接阶段会定位在外部函数的所在的位置, 将其关联起来, 如果外部函数没有找到引用符号的定义就报错.**

链接阶段将编译器阶段的产生的一系列的重定位符号链接条目表与定义全部关联起来.

**将会找到每个函数匹配的可执行函数的位置**
**代码扩展成的.o文件与所调用的系统函数(如: printf, scanf等).o(静态链接库)文件进行链接, 映射, 使代码能直接调用系统函数了.**

```shell
# 汇编器, 生成 .o 文件
gcc -c t.cpp 
# 或者
gcc -c t.s
```



在内存中, 一个共享库的.text节的一个副本可以被不同的正在运行的进程共享.

<font color=#b20> **链接器解析 : 就是将每个引用与它输入的可重定位目标文件的符号表中的每个符号定义相联起来. 根据符号定义也判断出数据节的大小.**
- **同时重定位节会重新将相同的文件类型的全部合并成同一个聚合节(.data合成一个块, .bss也是一样等等)**
- **链接器修改代码节和数据节中对每个符号的引用, 为他们重新指向正确的地址**
</font>


*对于多次定义的变量但是没有初始化的变量程序链接的时候相当于当成其当作是临时变量, 只分配占位符.*

- - -

- ### 可执行文件

1. 将二进制代码和数据链接生成一个可执行文件, 最后可执行文件复制到内存中, 通过跳转到程序的第一条代码或者是入口点开始执行程序.

```shell
# 输入 objdump -S 查看所有生成的汇编代码(包含了启动代码)
objdump -S a.out
```



程序真正的开始接口是从 _init, 它是为了程序初始化代码调用的, 由他调用 _lib的函数, 最后在由 _lib中调用 _start函数.

![018-04-23 13-42-21 的屏幕截](../../../图片/2018-04-23 13-42-21 的屏幕截图.png)
<font color=#b20> **_start函数调用系统启动的函数 _libc_start_main, 他在初始化执行环境时首先会调用_init, 调用用户层的main函数作为开始, main函数结束时返回值在必要的时候返回给内核.</font>**

从图中也可以看出 _start 函数调用启动函数 _libc_start_main.

![018-04-23 13-43-55 的屏幕截](../../../图片/2018-04-23 13-43-55 的屏幕截图.png)

2. 符号引用将符号定义的函数, 变量都连接起来, 最后将符号定义与分配在内存中的的资源空间, 地址关联起来. 使得每一个的变量, 函数都分配唯一的一个地址.
