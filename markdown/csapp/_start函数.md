## 可执行文件

当链接的时候, 系统会先调用 _init 函数, 程序的初始化需要调用它. 之后它就会调用 .plt 的系统函数.

PLT(过程链接表) 它有多个字段, 相当于一个数组.<font color=#b20>**协助完成动态链接**.
</font>
> 1. PLT[0] : 跳转到动态链接器. 被调用的系统函数都有他自己的链接条目.
> 2. PLT[1] : 初始化环境. 调用main函数, 并获得他的返回值.
> 3. PLT[2] : 跳转到用户代码的开始地址. 调用用户代码写的函数.

GOT(全局偏移量表)
> 1. GOT[0] GOT[1] : 动态链接在解析相关的地址时会用到的信息.
> 2. GOT[2] : 动态链接器在 ld-linux.so 模块的入口点.

**每个GOT条目初始化时都指向了对应的PLT条目的第二条指令, 当然这个间接跳转简单的把控制传送回PLT[2]的下一条指令.**

### 程序的入口

1. <font color=#b20>**在 _init 调用的时候后会接着调用 .plt 的函数, 做好初始化的工作, 接着在调用结束之后接着调用了 _start 系统函数, 引导程序从代码的开始地址执行.**</font>
2. <font color=#b20>**一直以为的 main 函数是程序的入口点, 其实不然, 在这里可以看出, main 函数并不是. 从图片也可以看到 _start 函数调用了一个 _libc_start_main 的函数, 能明白是 _start 调用了 启动了 main 函数, 也就是 _start 之后调用了main.**</font>
3. <font color=#b20>**_libc_start_main 函数是在 .lib 定义的. 而 libc 并不像其它目标文件一样链接到可执行文件main中，而是在运行时做动态链接的.**</font>
</font>

**libc 动态链接**
> a. 在加载执行main函数的时候, 会检查还有没有需要链接的符号.
> 
> b. 如果有, 就指定链接器到共享库查找这些符号定义.
> 
> c. 找到了, 就直接做链接.





