### 进程描述符

---

> <font color=#b20>**init0 进程通过内核初始化后调用init_task来静态分配.**



> 线程描述符在内核态栈的最高层, 内核栈大概有8kb的大小, 其他的7kb左右的位置都是给堆栈使用的.
>
> **linux通过使用slab分配器分配 task_struct结构, 它预先分配和重复使用task_struct, 可以避免动态的分配和资源回收所带来的消耗, 能达到对象的复用和缓存着色**
>
> 线程描述符的起始地址是指向 stak_struct 进程描述符的, 所以也就可以通过内核栈与0xfffe0000的屏蔽字相与就可以最快的速度获得进程描述的地址了.<font color=#b20>**这样仅通过内核栈就可以获得当前进程, 因为它在thread_info偏移量为0 的地方.**</font>
>
> <font color=#b20>**内核通过调用current宏, <==> current_thread_info()->task, 能够更加快速的查找进程的进程描述符**</font>
>
> 同样 进程描述符可以通过 thread_info 找到线程描述符.

> **有进程描述符为什么还要用PID描述进程呢?**
>
> 1. 如果查找PID都是直接通过进程描述符来查找, 这样的确实最简单的, 但这样每一个进程都去扫描一下进程描述符再去偏移查找PID这样是相当的花费时间的.
> 2. 采用PID链表的方法查找就可以避免这样的麻烦. 同时直接的PID查找可以采用hash散列表非常的快速.
> 3. PID的链表结构中也加上指向进程描述符的指针, 这样也可以提高快速的查找PID所对应的进程信息.