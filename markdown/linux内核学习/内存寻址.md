> 逻辑地址 --> 分段单元 --> 线性地址(虚拟地址) --> 分页单元 --> 物理地址
>
> 内存仲裁器 : 如果RAM芯片空闲, 就为准许一个CPU访问; 如果RAM忙碌, 会推迟CPU的访问.

### 逻辑地址

> **段选择符与段描述符**
>
> RPL : 请求者权限(0 : 内核态, 3 : 用户态)
>
> TI : 0 --> GDL中, 1 --> TDL中
>
> 索引号 : 与段描述符有关,  索引号 * 8 + (GDL / TDL) = 段描述符的位置(**可存放在非编程寄存器中**)
>
> 段描述符 :  当段选择符没发生改变时, 可以不用进行运算查找段描述符, 直接可以在非编程寄存器中引用; 但是当段选择器发生改变就得重新进行索引.

> <font color=#b20>**用户态和内核态都是共用同一个逻辑地址.**</font>这样是为了提高转换效率. 
>
> 如 : 将用户态的转为内核态, 只需要将 __USER_CS 转为  __KERNEL_CS 就可以了. 当发生跳转的时候也就只需要将用户态转为内核态同时加上偏移量就行了.

------

### 寄存器

> cr0 : 高数缓存的标识寄存器. 其中 NW 标志写回还是直写. 同时PG = 0时, 就将线性地址转为了物理地址.
>
> cr1 : 
>
> cr2 :	 当present被清零, 分页单元就将线性地址存放在控制寄存器cr2中, 并产生14号缺页异常.
>
> cr3 : **保存页全局目录基地址(swapper_pg_dir 存放主内核页全局目录指针的值). 当发生进车个切换的时候, 控制寄存器cr3将值存放在上一个进程描述符pdg中, 将新进程的进程描述符的pdg存放在cr3中. 这样内核就可以从新的进程的页表指向的地址开始执行, 完成进程的上下文切换.换句话说, <font color=#b20>进程的切换, 就相当于是页表的切换</font>**
>
> cr4 : Globle --> TLB(转化后援缓冲器). 没和就不采用上级页表, 中间页表来进行地址转换, 可以直接查询TLB缓存.

---

## 页表

<font color=#b20>**页表存放在主存中, 并在启动分页单元之前内核必须初始化页表.**</font>

当内核创建一个新的页全局目录时, 同时也会分配相应的页中间目录, 当内核释放父页全局目录, 对应的页中间目录才会释放.

### 物理内存布局

> **保护页框**
>
> 1. 物理地址超过了页框的范围
> 2. 内核的代码数据和已初始化的数据结构

> **内核为什么没有安装在RAM的开始地址?**
>
> - 页框0由 BIOS 使用
>
> - 物理地址从0x000a0000 到 0x000fffff 留给 BIOS 厉程
>
> - 第一个MB内的其他页框一般为特定的计算机而留.
>
> 	**总结 : 就是为 BIOS 的启动历程而留的.**

> **线性地址被划分成了哪两块?**    -- **进程页表**
>
> 1. 用户态 : 0x00000000 ~ 0xbfffffff 结束
> 2. 内核态 : 0xc0000000 ~ 0xffffffff 结束**只有内核态的进程才能寻址**. 一某些情况下, 内核也需要访问用户态的线性地址空间.

> **内核如何初始化自己的页表?**
>
> - 第一阶段 : 内核创建一个存放代码段和数据段的 128KB 的空间.仅能够将内核装入 RAM 和对其初始化数据结构.**采用的是实模式 : 用户态和内核态都可以在这个阶段直接的访问物理地址, 所以不是安全的, 需要由是模式转为保护模式**.
>
> 	页表存放在主存, 在分页单元启动的时候, 必须由内核初始化页表.
>
> - 第二阶段 : 充分利用剩下的 RAM 建立分页表.
>
> 

**临时页全局目录是在内核编译过程中静态的初始化的.**
