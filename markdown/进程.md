## 进程

---

### 进程切换

>**<font color=#b20>进程的切换, 就相当于是页表的切换</font>**
>
>**任何的进程切换都会更换活动页表**

> 1. **硬件上下文的一部分保存在段描述符的任务状态段(TSS), 将此时的寄存器(cs, es exp, eax等)保存起来.剩下一部分保存在内核态栈中, 也就是thread_struct类型的thread字段中.**
>
> 	**当发生进程切换的时侯都会调用thread字段.**
>
> 2. **进程切换的时侯会调用段选择符查找 GDT 表, 找到对应的段描述符, 并且读取任务状态段(TSS)的寄存器覆盖掉现在寄存器的值, 并将段描述符存入非编辑寄存器中, 最后找到执行进程的相应的物理地址. **
>
> 	**<font color=#b20>进程切换只会发生在内核态</font>所以TSS只会在GDT中**
>
> 3. **同时cr3寄存器将上一个进程描述符的pdg存放在它的内核态栈中.**
>
> 4. **将GDT(LDT)找到的物理地址传给cr3寄存器, cr3寄存器也就保存了新进程的页目录地址, 然后将内核态栈中保留在thread字段的数据提取出来.**

---

### 进程描述符

> 线程描述符在内核态栈的最高层, 内核栈大概有8kb的大小, 其他的7kb左右的位置都是给堆栈使用的.
>
> 线程描述符的起始地址是指向 stak_struct 进程描述符的, 所以也就可以通过内核栈与0xfffe0000的屏蔽字相与就可以最快的速度获得进程描述的地址了.<font color=#b20>**这样仅通过内核栈就可以获得当前进程, 因为它在thread_info偏移量为0 的地方.**</font>
>
> <font color=#b20>**内核通过调用current宏, <==> current_thread_info()->task**</font>
>
> 同样 进程描述符可以通过 thread_info 找到线程描述符.

> **有进程描述符为什么还要用PID描述进程呢?**
>
> 1. 如果查找PID都是直接通过进程描述符来查找, 这样的确实最简单的, 但这样每一个进程都去扫描一下进程描述符再去偏移查找PID这样是相当的花费时间的.
> 2. 采用PID链表的方法查找就可以避免这样的麻烦. 同时直接的PID查找可以采用hash散列表非常的快速.
> 3. PID的链表结构中也加上指向进程描述符的指针, 这样也可以提高快速的查找PID所对应的进程信息.

---

### init

> init0 : 

